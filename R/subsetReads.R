#' Subset the reads from read-level assays.
#'
#' @description
#' This function takes read names or indices and subsets them from the
#' specified assays of \code{\link[SummarizedExperiment]{RangedSummarizedExperiment}}
#' with read-level data. While subsetting of samples (the columns of the
#' SummarizedExperiment object) can be done easily (e.g. \code{se[, 1]}),
#' the reads are grouped by sample in read-level assays, and this function
#' provides a more convenient way to subset these nested reads.
#'
#' @param se A \code{\link[SummarizedExperiment]{RangedSummarizedExperiment}},
#'     typically generated by \code{\link{readModBam}} or
#'     \code{\link{readModkitExtract}}.
#' @param reads Defines reads to retain (or remove, if \code{invert=TRUE}).
#'     Either a character vector of read identifiers, or a named list in which
#'     names are samples from \code{colnames(se)} and the elements are
#'     index vectors (character, integer or logical) defining the reads for
#'     each sample.
#' @param prune A logical scalar. If \code{TRUE} (the default), samples for
#'     which the subsetting retains none of the reads will be completely removed
#'     from the returned \code{SummarizedExperiment} (also from \code{colData}
#'     and from assays that do not store read-level data). If \code{FALSE},
#'     such samples are retained (in the assays with read-level data as a
#'     zero-column \code{SparseMatrix}).
#' @param invert A logical scalar. If \code{FALSE} (the default), only the reads
#'     defined by \code{reads} are retained. If \code{invert=TRUE}, all reads
#'     except the ones in \code{reads} are retained.
#'
#' @return A subset \code{\link[SummarizedExperiment]{RangedSummarizedExperiment}}
#'     object.
#'
#' @author Michael Stadler
#'
#' @examples
#' modbamfiles <- system.file("extdata",
#'                            c("6mA_1_10reads.bam", "6mA_2_10reads.bam"),
#'                            package = "footprintR")
#' se <- readModBam(modbamfiles, "chr1:6940000-6955000", "a")
#' lapply(assay(se, "mod_prob"), colnames)
#'
#' # subset by read identifiers
#' seSub <- subsetReads(se, c("s1-233e48a7-f379-4dcf-9270-958231125563",
#'                            "s2-034b625e-6230-4f8d-a713-3a32cd96c298"))
#' lapply(assay(seSub, "mod_prob"), colnames)
#'
#' # subset by a list of indices
#' seSub <- subsetReads(se, list(s1 = c(1, 3),
#'                               s2 = c(TRUE, FALSE)))
#' lapply(assay(seSub, "mod_prob"), colnames)
#'
#' @importFrom SummarizedExperiment assay assay<- assayNames colnames
#'
#' @export
subsetReads <- function(se,
                        reads,
                        prune = TRUE,
                        invert = FALSE) {
    # digest arguments
    .assertVector(x = se, type = "SummarizedExperiment")
    .checkSEValidity(se, verbose = FALSE)
    rlAssays <- .getReadLevelAssayNames(se)
    sampleNms <- SummarizedExperiment::colnames(se)
    if (length(rlAssays) == 0) {
        warning("'se' contains no read-level assays - no subsetting done")
        return(se)
    }
    rlAssayColnames <- lapply(SummarizedExperiment::assay(se, rlAssays[1]),
                              colnames)
    .assertScalar(x = prune, type = "logical")

    ## make sure that 'reads' is a named list with all samples and
    ## (possibly zero-length) character elements with read identifiers
    if (is.character(reads)) {
        # map read identifiers to samples
        read2sample <- structure(rep(names(rlAssayColnames),
                                     lengths(rlAssayColnames)),
                                 names = unlist(rlAssayColnames,
                                                use.names = FALSE))
        if (any(i <- !reads %in% names(read2sample))) {
            stop("'reads' contains unknown identifiers: ",
                 paste(reads[i], collapse = ", "))
        }
        reads <- split(reads, read2sample[reads])[
            intersect(sampleNms, unique(read2sample))]
    }

    if (is.list(reads)) {
        if (is.null(names(reads)) || any(!names(reads) %in% sampleNms)) {
            stop("'reads' of type list must have names in: ",
                 paste(sampleNms, collapse = ", "))
        }
        for (snm in sampleNms) {
            if (is.null(reads[[snm]])) {
                reads[[snm]] <- character(0L)
            } else {
                valid_nms <- rlAssayColnames[[snm]]
                if (is.character(reads[[snm]])) {
                    if (any(i <- !reads[[snm]] %in% valid_nms)) {
                        stop("'reads' for sample '", snm, "' contains unknown read ",
                             "names: ", paste(reads[[snm]][i], collapse = ", "))
                    }
                } else if (is.numeric(reads[[snm]])) {
                    if (any(i <- reads[[snm]] < 1 | reads[[snm]] > length(valid_nms))) {
                        stop("'reads' for sample '", snm, "' contains out-of-range ",
                             "indices: ", paste(reads[[snm]][i], collapse = ", "))
                    }
                    reads[[snm]] <- rlAssayColnames[[snm]][reads[[snm]]]
                } else if (is.logical(reads[[snm]])) {
                    if (length(reads[[snm]]) != length(valid_nms)) {
                        stop("logical 'reads' for sample '", snm, "' must be of ",
                             "length ", length(valid_nms))
                    }
                    reads[[snm]] <- rlAssayColnames[[snm]][reads[[snm]]]
                }
            }
        }
    } else {
        stop("'reads' must be either a character vector with reads names ",
             "or a named list with read indices.")
    }

    ## invert selection
    if (invert) {
        reads <- lapply(structure(sampleNms, names = sampleNms),
                        function(snm) setdiff(rlAssayColnames[[snm]],
                                              reads[[snm]]))
    }

    ## subset reads
    for (anm in rlAssays) {
        dframe <- SummarizedExperiment::assay(se, anm)
        for (snm in names(reads)) {
            dframe[[snm]] <- dframe[[snm]][, reads[[snm]], drop = FALSE]
        }
        suppressWarnings(
            # currently, assigning to assays triggers a depreceation warning
            # (introduced in https://github.com/Bioconductor/IRanges/commit/b4e9e7e8530a822980259c37cef186c652ba8be5)
            # see issue at https://github.com/Bioconductor/SummarizedExperiment/issues/74
            SummarizedExperiment::assay(se, anm) <- dframe
        )
    }

    ## subset samples
    if (prune) {
        keepSamples <- lengths(reads[sampleNms]) > 0
        if (!all(keepSamples)) {
            se <- se[, keepSamples]
        }
    }

    .checkSEValidity(se, verbose = FALSE)
    return(se)
}
