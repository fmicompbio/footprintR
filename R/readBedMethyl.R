#' Read collapsed single-molecule footprinting data from a `bedMethyl` file.
#'
#' @description
#' This function will read collapsed single-molecule footprinting data
#' (reads combined per genomic position) from a \code{bedMethyl} file.
#'
#' @param fnames Character vector with one or several paths of \code{bedMethyl}
#'     files, such as generated by \code{modkit pileup}. Each file will be read
#'     separately and become one of the columns in the returned
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} object.
#'     If \code{fnames} is a named vector, the names are used as column names in
#'     the returned object. Otherwise, the column names will be \code{s1}, ...,
#'     \code{sN}, where \code{N} is the length of \code{fnames}.
#'     If several elements of \code{fnames} have identical
#'     names, the data from the corresponding files are summed into a single
#'     column in the returned object.
#' @param modbase Character vector defining the modified base (or bases) to
#'     read. Useful for reading a subset of the data from \code{bedMethyl} files
#'     that contain multiple types of modified bases. If \code{NULL} (the
#'     default), all rows in the input file are read.
#' @param nrows Only read \code{nrows} rows of the input file.
#' @param seqlens \code{NULL} or a named vector of sequence lengths for genomic
#'     sequences (chromosomes). Useful to set the sorting order of sequence names.
#' @param verbose If \code{TRUE}, report on progress.
#'
#' @return A \code{\link[SummarizedExperiment]{SummarizedExperiment}} object
#'     with genomic positions in rows and samples (the unique names of
#'     \code{fnames}) in the columns.
#'
#' @author Michael Stadler
#'
#' @examples
#' bmfile <- system.file("extdata", "modkit_pileup_1.bed.gz", package = "footprintR")
#' readBedMethyl(bmfile)
#'
#' @seealso [`modkit` software](https://nanoporetech.github.io/modkit),
#'     [`bedMethyl` format description](https://nanoporetech.github.io/modkit/intro_bedmethyl.html#description-of-bedmethyl-output),
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} for the returned object type,
#'     \code{\link[data.table]{fread}} for the function used to read the input files
#'
#' @importFrom SummarizedExperiment SummarizedExperiment assayNames
#' @importFrom data.table fread
#' @importFrom GenomicRanges GPos match sort
#' @importFrom scuttle aggregateAcrossCells
#'
#' @export
readBedMethyl <- function(fnames, modbase = NULL, nrows = Inf,
                          seqlens = NULL, verbose = FALSE) {
    # digest arguments
    .assertVector(x = fnames, type = "character")
    if (any(i <- !file.exists(fnames))) {
        stop("not all `fnames` exist: ", paste(fnames[i], collapse = ", "))
    }
    .assertVector(x = modbase, type = "character", allowNULL = TRUE)
    .assertScalar(x = nrows, type = "numeric", rngIncl = c(1, Inf))
    .assertScalar(x = seqlens, type = "numeric", allowNULL = TRUE)
    if (!is.null(seqlens) && (is.null(names(seqlens)) || any(duplicated(names(seqlens))))) {
        stop("`seqlens` needs to be a named vector with lengths for unique sequence names.")
    }
    .assertScalar(x = verbose, type = "logical")
    if (any(grepl("[.](gz|bz2)$", fnames))) {
        .assertPackagesAvailable("R.utils")
    }

    # get sample names
    if (!is.null(names(fnames))) {
        nms <- names(fnames)
    } else {
        nms <- paste0("s", seq_along(fnames))
    }

    # load data
    if (verbose) {
        message("reading input files")
    }
    dfL <- lapply(fnames, function(fname) {
        if (verbose) {
            message("    ", fname)
        }
        data.table::fread(
            file = fname, sep = "\t", nrows = nrows, header = FALSE,
            nThread = 1, data.table = FALSE, verbose = FALSE,
            col.names = c("chr", "modbase", "strand", "start", "N_valid", "N_mod"),
            select = list(character = c(1, 4, 6), integer = c(2, 10, 12)))
    })

    # filter by `modbase`
    if (!is.null(modbase)) {
        if (verbose) {
            message("filtering modifications (retaining '", modbase, "'")
        }
        dfL <- lapply(dfL, function(df) {
            df[df$modbase %in% modbase, ]
        })
    }

    # create GPos objects for each input
    # (convert 0-based start from bed format to 1-based start in GenomicRanges)
    gposL <- lapply(dfL, function(df) {
        GenomicRanges::GPos(seqnames = df$chr, pos = df$start + 1L,
                            strand = df$strand, seqlengths = seqlens)
    })

    # create combined GPos
    if (length(dfL) > 1) {
        if (verbose) {
            message("finding unique genomic positions...", appendLF = FALSE)
        }
        gpos <- GenomicRanges::sort(unique(do.call(c, unname(gposL))))
        if (verbose) {
            message("collapsed ", sum(lengths(gposL)), " positions to ",
                    length(gpos), " unique ones")
        }
    } else {
        gpos <- GenomicRanges::sort(gposL[[1]])
    }
    }

    # create assays
    nmod <- nval <- matrix(data = 0, nrow = length(gpos), ncol = length(dfL),
                           dimnames = list(NULL, nms))
    for (i in seq_along(dfL)) {
        i_row <- GenomicRanges::match(gposL[[i]], gpos)
        nmod[i_row, i] <- dfL[[i]]$N_mod
        nval[i_row, i] <- dfL[[i]]$N_valid
    }

    # create summarized experiment
    se <- SummarizedExperiment(
        assays = list(Nmod = nmod, Nvalid = nval),
        rowRanges = gpos)

    # collapse to unique names
    if (any(duplicated(nms))) {
        se <- scuttle::aggregateAcrossCells(
            x = se,
            ids = nms,
            statistics = "sum",
            suffix = FALSE,
            store_number = "nfiles",
            use.assay.type = assayNames(se)
        )
    }

    # return
    return(se)
}
