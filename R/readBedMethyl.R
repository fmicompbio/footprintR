#' Read collapsed single-molecule footprinting data from a `bedMethyl` file.
#'
#' @description
#' This function will read collapsed single-molecule footprinting data
#' (reads combined per genomic position) from a \code{bedMethyl} file.
#'
#' @param fnames Character vector with one or several paths of \code{bedMethyl}
#'     files, such as generated by \code{modkit pileup}. Each file will be read
#'     separately and become one of the columns in the returned
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} object.
#'     If \code{fnames} is a named vector, the names are used as column names in
#'     the returned object. Otherwise, the column names will be \code{s1}, ...,
#'     \code{sN}, where \code{N} is the length of \code{fnames}.
#'     If several elements of \code{fnames} have identical
#'     names, the data from the corresponding files are summed into a single
#'     column in the returned object.
#' @param modbase Character vector defining the modified base for each sample.
#'     If \code{modbase} is a named vector, the names should correspond to
#'     the names of \code{fnames}. Otherwise, it will be assumed that the
#'     elements are in the same order as the files in \code{fnames}. If
#'     \code{modbase} has length 1, the same modified base will be used for
#'     all samples.
#' @param nrows Only read \code{nrows} rows of the input file.
#' @param seqinfo \code{NULL} or a \code{\link[GenomeInfoDb]{Seqinfo}} object
#'     containing information about the set of genomic sequences (chromosomes).
#'     Alternatively, a named numeric vector with genomic sequence names and
#'     lengths. Useful to set the sorting order of sequence names.
#' @param sequence.context.width,sequence.reference Define the sequence
#'     context to be extracted around modified bases. By default (
#'     \code{sequence.context.width = 0}), no sequence context will be
#'     extracted, otherwise it will be returned in \code{rowData(x)$sequence.context}.
#'     See \code{\link{addSeqContext}} for details.
#' @param ncpu A numeric scalar giving the number of parallel CPU threads to
#'     to use for some of the steps in \code{readBedMethyl()}.
#' @param verbose If \code{TRUE}, report on progress.
#'
#' @return A \code{\link[SummarizedExperiment]{SummarizedExperiment}} object
#'     with genomic positions in rows and samples (the unique names of
#'     \code{fnames}) in the columns. If \code{sequence.context.width != 0},
#'     \code{rowData(x)$sequence.context} will be a \code{\link[Biostrings]{DNAStringSet}}
#'     object with the extracted sequences.
#'
#' @author Michael Stadler
#'
#' @examples
#' bmfile <- system.file("extdata", "modkit_pileup_1.bed.gz", package = "footprintR")
#' readBedMethyl(bmfile, modbase = "m")
#'
#' @seealso [`modkit` software](https://nanoporetech.github.io/modkit),
#'     [`bedMethyl` format description](https://nanoporetech.github.io/modkit/intro_bedmethyl.html#description-of-bedmethyl-output),
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} for the returned object type,
#'     \code{\link[data.table]{fread}} for the function used to read the input files,
#'     \code{\link{addSeqContext}} used to add the sequence context.
#'
#' @import SummarizedExperiment
#' @importFrom data.table fread
#' @importFrom GenomicRanges GPos match sort resize trim
#' @importFrom GenomeInfoDb seqlengths seqlengths<-
#' @importFrom S4Vectors mcols mcols<- DataFrame
#' @importFrom scuttle aggregateAcrossCells
#' @importFrom Biostrings readDNAStringSet DNAStringSet
#' @importFrom BSgenome getSeq
#' @importFrom methods as is
#' @importFrom parallel mclapply detectCores
#'
#' @export
readBedMethyl <- function(fnames,
                          modbase,
                          nrows = Inf,
                          seqinfo = NULL,
                          sequence.context.width = 0,
                          sequence.reference = NULL,
                          ncpu = 1L,
                          verbose = FALSE) {
    # digest arguments
    .assertVector(x = fnames, type = "character")
    if (any(i <- !file.exists(fnames))) {
        stop("not all `fnames` exist: ", paste(fnames[i], collapse = ", "))
    }
    if (is.null(names(fnames))) {
        names(fnames) <- paste0("s", seq_along(fnames))
    }
    if (length(modbase) == 1) {
        modbase <- rep(modbase, length(fnames))
    }
    .assertVector(x = modbase, type = "character", len = length(fnames))
    if (is.null(names(modbase))) {
        names(modbase) <- names(fnames)
    } else {
        if (!all(names(modbase) %in% names(fnames))) {
            stop("names of `modbase` and `fnames` don't agree")
        }
    }
    # for valid values of `modbase`, see
    # https://samtools.github.io/hts-specs/SAMtags.pdf (section 1.7)
    if (any(i <- !modbase %in% c("m","h","f","c","C","g","e","b","T",
                                 "U","a","A","o","G","n","N"))) {
        stop("invalid `modbase` values: ",
             paste(unique(modbase[i]), collapse = ", "))
    }
    .assertScalar(x = nrows, type = "numeric", rngIncl = c(1, Inf))
    if (!is.null(seqinfo)) {
        if (!is(seqinfo, "Seqinfo") &&
            (!is.numeric(seqinfo) || is.null(names(seqinfo)))) {
            stop("`seqinfo` must be `NULL`, a `Seqinfo` object or a named",
                 " numeric vector with genomic sequence lengths.")
        }
    }
    .assertScalar(x = sequence.context.width, type = "numeric", rngIncl = c(0, 1000))
    .assertScalar(x = ncpu, type = "numeric", rngIncl = c(1, parallel::detectCores()))
    .assertScalar(x = verbose, type = "logical")
    if (any(grepl("[.](gz|bz2)$", fnames))) {
        .assertPackagesAvailable("R.utils")
    }

    # get sample names
    nms <- names(fnames)

    # load data
    if (verbose) {
        message("reading input files")
    }
    dfL <- lapply(fnames, function(fname) {
        if (verbose) {
            message("    ", fname)
        }
        data.table::fread(
            file = fname, sep = "\t", nrows = nrows, header = FALSE,
            nThread = ncpu, data.table = FALSE, verbose = FALSE,
            col.names = c("chr", "modbase", "strand", "start", "N_valid", "N_mod"),
            select = list(character = c(1, 4, 6), integer = c(2, 10, 12)))
    })

    # filter by `modbase`
    if (!is.null(modbase)) {
        if (verbose) {
            message("filtering modifications (retaining ", paste(modbase, collapse = ", "), ")")
        }
        dfL <- parallel::mclapply(dfL, function(df) {
            df[df$modbase %in% modbase, ]
        }, mc.cores = ncpu)
    }

    # create GPos objects for each input
    # (convert 0-based start from bed format to 1-based start in GenomicRanges)
    gposL <- parallel::mclapply(dfL, function(df) {
        GenomicRanges::GPos(seqnames = df$chr, pos = df$start + 1L,
                            strand = df$strand, seqinfo = seqinfo)
    }, mc.cores = ncpu)

    # create combined GPos
    if (length(dfL) > 1) {
        if (verbose) {
            message("finding unique genomic positions...", appendLF = FALSE)
        }
        gpos <- GenomicRanges::sort(unique(do.call(c, unname(gposL))))
        if (verbose) {
            message("collapsed ", sum(lengths(gposL)), " positions to ",
                    length(gpos), " unique ones")
        }
    } else {
        gpos <- GenomicRanges::sort(gposL[[1]])
    }

    # add sequence context
    if (sequence.context.width > 0) {
        if (verbose) {
            message("extracting sequence contexts")
        }
        mcols(gpos)$sequence.context <- extractSeqContext(
            x = as(gpos, "GRanges"),
            sequence.context.width = sequence.context.width,
            sequence.reference = sequence.reference)
    }

    # create assays
    nmod <- nval <- matrix(data = 0, nrow = length(gpos), ncol = length(dfL),
                           dimnames = list(NULL, nms))
    for (i in seq_along(dfL)) {
        i_row <- GenomicRanges::match(gposL[[i]], gpos)
        nmod[i_row, i] <- dfL[[i]]$N_mod
        nval[i_row, i] <- dfL[[i]]$N_valid
    }

    # create summarized experiment
    se <- SummarizedExperiment::SummarizedExperiment(
        assays = list(Nmod = nmod, Nvalid = nval),
        rowRanges = gpos,
        colData = S4Vectors::DataFrame(
            row.names = names(fnames),
            sample = names(fnames),
            modbase = modbase[names(fnames)]
        ),
        metadata = list(readLevelData = list(assayNames = c(),
                                             colDataColumns = c())))

    # collapse to unique names
    if (any(duplicated(nms))) {
        se <- scuttle::aggregateAcrossCells(
            x = se,
            ids = nms,
            statistics = "sum",
            suffix = FALSE,
            store_number = "nfiles",
            use.assay.type = assayNames(se)
        )
    }

    # return
    return(se)
}
