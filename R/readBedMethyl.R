#' Read collapsed single-molecule footprinting data from a `bedMethyl` file.
#'
#' @description
#' This function will read collapsed single-molecule footprinting data
#' (reads combined per genomic position) from a \code{bedMethyl} file.
#'
#' @param fnames Character vector with one or several paths of \code{bedMethyl}
#'     files, such as generated by \code{modkit pileup}. Each file will be read
#'     separately and become one of the columns in the returned
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} object.
#'     If \code{fnames} is a named vector, the names are used as column names in
#'     the returned object. Otherwise, the column names will be \code{s1}, ...,
#'     \code{sN}, where \code{N} is the length of \code{fnames}.
#'     If several elements of \code{fnames} have identical
#'     names, the data from the corresponding files are summed into a single
#'     column in the returned object.
#' @param modbase Character vector defining the modified base (or bases) to
#'     read. Useful for reading a subset of the data from \code{bedMethyl} files
#'     that contain multiple types of modified bases. If \code{NULL} (the
#'     default), all rows in the input file are read.
#' @param nrows Only read \code{nrows} rows of the input file.
#' @param seqinfo \code{NULL} or a \code{\link[GenomeInfoDb]{Seqinfo}} object
#'     containing information about the set of genomic sequences (chromosomes).
#'     Alternatively, a named numeric vector with genomic sequence names and
#'     lengths. Useful to set the sorting order of sequence names.
#' @param sequence.context.width A numeric scalar giving the width of the
#'     sequence context to be extracted from the reference
#'     (\code{sequence.reference} argument). The context will be centered on the
#'     modified base. If \code{sequence.context.width = 0} (the default), no
#'     sequence context will be extracted.
#' @param sequence.reference A \code{\link[BSgenome]{BSgenome}} object, or a
#'     character scalar giving the path to a fasta formatted file with reference
#'     sequences, or a \code{\link[Biostrings]{DNAStringSet}} object.
#'     The sequence context (see \code{sequence.context.width} argument) will be
#'     extracted from these sequences.
#' @param ncpu A numeric scalar giving the number of parallel CPU threads to
#'     to use for some of the steps in \code{readBedMethyl()}.
#' @param verbose If \code{TRUE}, report on progress.
#'
#' @return A \code{\link[SummarizedExperiment]{SummarizedExperiment}} object
#'     with genomic positions in rows and samples (the unique names of
#'     \code{fnames}) in the columns.
#'
#' @author Michael Stadler
#'
#' @examples
#' bmfile <- system.file("extdata", "modkit_pileup_1.bed.gz", package = "footprintR")
#' readBedMethyl(bmfile)
#'
#' @seealso [`modkit` software](https://nanoporetech.github.io/modkit),
#'     [`bedMethyl` format description](https://nanoporetech.github.io/modkit/intro_bedmethyl.html#description-of-bedmethyl-output),
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} for the returned object type,
#'     \code{\link[data.table]{fread}} for the function used to read the input files
#'
#' @import SummarizedExperiment
#' @importFrom data.table fread
#' @importFrom GenomicRanges GPos match sort resize trim
#' @importFrom GenomeInfoDb seqlengths seqlengths<-
#' @importFrom S4Vectors mcols mcols<-
#' @importFrom scuttle aggregateAcrossCells
#' @importFrom Biostrings readDNAStringSet DNAStringSet
#' @importFrom BSgenome getSeq
#' @importFrom methods as is
#' @importFrom parallel mclapply detectCores
#'
#' @export
readBedMethyl <- function(fnames,
                          modbase = NULL,
                          nrows = Inf,
                          seqinfo = NULL,
                          sequence.context.width = 0,
                          sequence.reference = NULL,
                          ncpu = 1L,
                          verbose = FALSE) {
    # digest arguments
    .assertVector(x = fnames, type = "character")
    if (any(i <- !file.exists(fnames))) {
        stop("not all `fnames` exist: ", paste(fnames[i], collapse = ", "))
    }
    .assertVector(x = modbase, type = "character", allowNULL = TRUE)
    .assertScalar(x = nrows, type = "numeric", rngIncl = c(1, Inf))
    if (!is.null(seqinfo)) {
        if (!is(seqinfo, "Seqinfo") &&
            (!is.numeric(seqinfo) || is.null(names(seqinfo)))) {
            stop("`seqinfo` must be `NULL`, a `Seqinfo` object or a named",
                 " numeric vector with genomic sequence lengths.")
        }
    }
    .assertScalar(x = sequence.context.width, type = "numeric", rngIncl = c(0, 100))
    if (sequence.context.width > 0) {
        if (is.null(sequence.reference)) {
            stop("`sequence.reference` must be provided if `sequence.context.width`",
                 " is not zero.")
        } else if (!is(sequence.reference, "BSgenome") &&
                   !is(sequence.reference, "DNAStringSet") &&
                   !(is.character(sequence.reference) && file.exists(sequence.reference))) {
            stop("`sequence.reference` must be either a BSgenome object, ",
                 "a DNAStringSet object, or a path to a fasta file.")
        }

    }
    .assertScalar(x = ncpu, type = "numeric", rngIncl = c(1, parallel::detectCores()))
    .assertScalar(x = verbose, type = "logical")
    if (any(grepl("[.](gz|bz2)$", fnames))) {
        .assertPackagesAvailable("R.utils")
    }

    # get sample names
    if (!is.null(names(fnames))) {
        nms <- names(fnames)
    } else {
        nms <- paste0("s", seq_along(fnames))
    }

    # load data
    if (verbose) {
        message("reading input files")
    }
    dfL <- lapply(fnames, function(fname) {
        if (verbose) {
            message("    ", fname)
        }
        data.table::fread(
            file = fname, sep = "\t", nrows = nrows, header = FALSE,
            nThread = ncpu, data.table = FALSE, verbose = FALSE,
            col.names = c("chr", "modbase", "strand", "start", "N_valid", "N_mod"),
            select = list(character = c(1, 4, 6), integer = c(2, 10, 12)))
    })

    # filter by `modbase`
    if (!is.null(modbase)) {
        if (verbose) {
            message("filtering modifications (retaining ", paste(modbase, collapse = ", "), ")")
        }
        dfL <- parallel::mclapply(dfL, function(df) {
            df[df$modbase %in% modbase, ]
        }, mc.cores = ncpu)
    }

    # create GPos objects for each input
    # (convert 0-based start from bed format to 1-based start in GenomicRanges)
    gposL <- parallel::mclapply(dfL, function(df) {
        GenomicRanges::GPos(seqnames = df$chr, pos = df$start + 1L,
                            strand = df$strand, seqinfo = seqinfo)
    }, mc.cores = ncpu)

    # create combined GPos
    if (length(dfL) > 1) {
        if (verbose) {
            message("finding unique genomic positions...", appendLF = FALSE)
        }
        gpos <- GenomicRanges::sort(unique(do.call(c, unname(gposL))))
        if (verbose) {
            message("collapsed ", sum(lengths(gposL)), " positions to ",
                    length(gpos), " unique ones")
        }
    } else {
        gpos <- GenomicRanges::sort(gposL[[1]])
    }

    # add sequence context
    if (sequence.context.width > 0) {
        if (verbose) {
            message("extracting sequence contexts")
        }
        grcontext <- resize(as(gpos, "GRanges"),
                            width = sequence.context.width,
                            fix = "center")
        if (is.character(sequence.reference)) {
            gnm <- Biostrings::readDNAStringSet(sequence.reference)
            names(gnm) <- sub(" .*$", "", names(gnm))
        } else {
            gnm <- sequence.reference
        }
        if (is.null(seqinfo)) {
            seqlengths(gpos) <- seqlengths(gnm)
        }
        Npre <- pmax(0L, 1L - start(grcontext))
        Npost <- pmax(0L, end(grcontext) - seqlengths(gnm)[as.character(seqnames(grcontext))])
        if (any(Npre > 0) || any(Npost > 0)) {
            suppressWarnings(seqlengths(grcontext) <- seqlengths(gnm))
            grcontext <- GenomicRanges::trim(grcontext)
            seqcontext <- DNAStringSet(
                x = paste0(strrep("N", Npre),
                           getSeq(gnm, grcontext),
                           strrep("N", Npost)),
                use.names = FALSE)
        } else {
            seqcontext <- getSeq(gnm, grcontext)
        }
        mcols(gpos)$sequence.context <- seqcontext
    }

    # create assays
    nmod <- nval <- matrix(data = 0, nrow = length(gpos), ncol = length(dfL),
                           dimnames = list(NULL, nms))
    for (i in seq_along(dfL)) {
        i_row <- GenomicRanges::match(gposL[[i]], gpos)
        nmod[i_row, i] <- dfL[[i]]$N_mod
        nval[i_row, i] <- dfL[[i]]$N_valid
    }

    # create summarized experiment
    se <- SummarizedExperiment(
        assays = list(Nmod = nmod, Nvalid = nval),
        rowRanges = gpos)

    # collapse to unique names
    if (any(duplicated(nms))) {
        se <- scuttle::aggregateAcrossCells(
            x = se,
            ids = nms,
            statistics = "sum",
            suffix = FALSE,
            store_number = "nfiles",
            use.assay.type = assayNames(se)
        )
    }

    # return
    return(se)
}
