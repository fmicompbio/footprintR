#' Read modkit extract file(s)
#'
#' @description
#' This function reads one or more modkit extract files and generates a
#' single SummarizedExperiment object with rows representing positions and
#' columns representing reads. The SummarizedExperiment object
#' contains one assay (\code{mod_prob}) with modification probabilities for
#' each position in each read. Unobserved read/position combinations are
#' represented by a zero, while all values that are 'implicitly' called by
#' modkit (with a modification probability less than 5%) are represented with
#' a value of 0.02.
#'
#' @param fnames Character vector with one or several paths of \code{extract.tsv}
#'     files, such as generated by \code{modkit}. If \code{fnames} is a named
#'     vector, the names are used as prefixes for the column (read) names in
#'     the returned \code{SummarizedExperiment} object. Otherwise, the prefixes
#'     will be \code{s1}, ..., \code{sN}, where \code{N} is the length of
#'     \code{fnames}.
#' @param modbase Character vector defining the modified base for each sample.
#'     If \code{modbase} is a named vector, the names should correspond to
#'     the names of \code{fnames}. Otherwise, it will be assumed that the
#'     elements are in the same order as the files in \code{fnames}. If
#'     \code{modbase} has length 1, the same modified base will be used for
#'     all samples.
#' @param filter Either \code{NULL} (no filtering is performed),
#'     \code{"modkit"} (only records where the \code{"fail"} column in the
#'     extract file is \code{FALSE} are retained), or a named vector, providing
#'     filter thresholds (on the call probability) for the
#'     unmodified and modified bases, respectively. The names of the vector
#'     should be \code{"-"} and the value(s) in \code{modbase}.
#' @param nrows Only read \code{nrows} rows of each input file.
#' @param seqinfo \code{NULL} or a \code{\link[GenomeInfoDb]{Seqinfo}} object
#'     containing information about the set of genomic sequences (chromosomes).
#'     Alternatively, a named numeric vector with genomic sequence names and
#'     lengths. Useful to set the sorting order of sequence names.
#' @param ncpu A numeric scalar giving the number of parallel CPU threads to
#'     to use for some of the steps in \code{readModkitExtract()}.
#' @param verbose If \code{TRUE}, report on progress.
#'
#' @return A \code{\link[SummarizedExperiment]{SummarizedExperiment}} object
#'     with genomic positions in rows and samples in columns. The assay
#'     \code{"mod_prob"} contains per-read modification probabilities,
#'     with each column (sample) corresponding to a position-by-read
#'     \code{\link[SparseArray]{SparseMatrix}}.
#'
#' @author Charlotte Soneson
#'
#' @examples
#' extrfile <- system.file("extdata", "modkit_extract_rc_5mC_1.tsv.gz",
#'                         package = "footprintR")
#' ## ... no filtering
#' readModkitExtract(extrfile, modbase = "m", filter = NULL)
#' ## ... modkit filtering
#' readModkitExtract(extrfile, modbase = "m", filter = "modkit")
#'
#' @seealso [`modkit` software](https://nanoporetech.github.io/modkit),
#'     \code{\link[SummarizedExperiment]{SummarizedExperiment}} for the returned object type,
#'     \code{\link[data.table]{fread}} for the function used to read the input files
#'
#' @importFrom SummarizedExperiment SummarizedExperiment colData rowRanges
#' @importFrom data.table fread
#' @importFrom parallel mclapply
#' @importFrom GenomicRanges GPos sort match
#' @importFrom S4Vectors make_zero_col_DFrame DataFrame
#' @importFrom SparseArray SparseArray
#' @importFrom Matrix sparseMatrix
#' @importFrom BiocGenerics pos strand do.call cbind
#' @importFrom GenomeInfoDb seqnames
#'
#' @export
readModkitExtract <- function(fnames,
                              modbase,
                              filter = NULL,
                              nrows = Inf,
                              seqinfo = NULL,
                              ncpu = 1L,
                              verbose = FALSE) {

    # digest arguments
    .assertVector(x = fnames, type = "character")
    if (any(i <- !file.exists(fnames))) {
        stop("not all `fnames` exist: ", paste(fnames[i], collapse = ", "))
    }
    if (length(modbase) == 1) {
        modbase <- rep(modbase, length(fnames))
    }
    .assertVector(x = modbase, type = "character", len = length(fnames))
    if (!is.null(names(modbase))) {
        if (!all(names(modbase) %in% names(fnames))) {
            stop("names of `modbase` and `fnames` don't agree")
        }
    }
    if (!is.null(filter)) {
        if (is.character(filter)) {
            .assertScalar(x = filter, type = "character", validValues = "modkit")
        } else {
            .assertVector(x = filter, type = "numeric", rngIncl = c(0, 1))
            if (is.null(names(filter))) {
                stop("`filter` must be a named vector")
            }
            if (any(i <- !(unique(c("-", modbase))) %in% names(filter))) {
                stop("a filter threshold needs to be supplied for all ",
                     "modified bases, not present for: ",
                     unique(c("-", modbase))[i])
            }
        }
    }
    .assertScalar(x = nrows, type = "numeric", rngIncl = c(1, Inf))
    if (!is.null(seqinfo)) {
        if (!is(seqinfo, "Seqinfo") &&
            (!is.numeric(seqinfo) || is.null(names(seqinfo)))) {
            stop("`seqinfo` must be `NULL`, a `Seqinfo` object or a named",
                 " numeric vector with genomic sequence lengths.")
        }
    }
    .assertScalar(x = ncpu, type = "numeric")
    .assertScalar(x = verbose, type = "logical")
    if (any(grepl("[.](gz|bz2)$", fnames))) {
        .assertPackagesAvailable("R.utils")
    }

    # get sample names
    if (!is.null(names(fnames))) {
        nms <- names(fnames)
    } else {
        nms <- paste0("s", seq_along(fnames))
        names(fnames) <- nms
    }
    if (is.null(names(modbase))) {
        names(modbase) <- names(fnames)
    }

    # load data
    if (verbose) {
        message("reading input files")
    }
    # pre-allocate lists for data and filter thresholds
    dfL <- vector("list", length = length(fnames))
    modkit_threshold <- vector("list", length = length(fnames))
    filter_threshold <- vector("list", length = length(fnames))
    names(dfL) <- names(modkit_threshold) <-
        names(filter_threshold) <- names(fnames)
    for (nm in names(fnames)) {
        if (verbose) {
            message("    ", fnames[nm])
        }
        # read data
        tmp <- data.table::fread(
            file = fnames[nm], sep = "\t", nrows = nrows, header = TRUE,
            nThread = ncpu, data.table = FALSE, verbose = FALSE,
            select = list(character = c("chrom", "call_code", "read_id", "ref_strand"),
                          integer = c("ref_position"),
                          logical = c("fail"),
                          numeric = c("call_prob")))
        # keep only rows corresponding to specified modbase or '-'
        tmp <- tmp[tmp$call_code %in% c(modbase[nm], "-"), ]
        # calculate modification probability
        tmp$mod_prob <- ifelse(tmp$call_code == modbase[nm], tmp$call_prob,
                               1 - tmp$call_prob)
        # set zeros to small value for unmodified positions
        # (dorado omits base modification probabilities less than 0.05)
        tmp$mod_prob[tmp$call_code == "-" & tmp$mod_prob == 0] <- 0.02
        # record filter threshold implied by modkit
        mod_fail_idx <- which(tmp$fail & tmp$call_code == modbase[nm])
        unmod_fail_idx <- which(tmp$fail & tmp$call_code == "-")
        modkit_threshold[[nm]] <- structure(
            c(ifelse(length(mod_fail_idx) > 0,
                     max(tmp$call_prob[mod_fail_idx]), -Inf),
              ifelse(length(unmod_fail_idx) > 0,
                     max(tmp$call_prob[unmod_fail_idx]), -Inf)),
            names = c(modbase[nm], "-")
        )
        # filter
        if (!is.null(filter)) {
            if (is.character(filter) && filter == "modkit") {
                tmp <- tmp[!tmp$fail, ]
                filter_threshold[[nm]] <- modkit_threshold[[nm]]
            } else if (is.numeric(filter)) {
                tmp <- tmp[(tmp$call_code == "-" & tmp$call_prob > filter["-"]) |
                               (tmp$call_code == modbase[nm] &
                                    tmp$call_prob > filter[modbase[nm]]), ]
                filter_threshold[[nm]] <- filter
            }
        }
        # convert to 1-based positions
        tmp$ref_position <- tmp$ref_position + 1
        dfL[[nm]] <- tmp
    }

    # create GPos objects for each input
    gposL <- parallel::mclapply(dfL, function(df) {
        GenomicRanges::GPos(seqnames = df$chrom, pos = df$ref_position,
                            strand = df$ref_strand, seqinfo = seqinfo)
    }, mc.cores = ncpu)

    # create combined GPos, reduce to unique positions
    if (verbose) {
        message("finding unique genomic positions...", appendLF = FALSE)
    }
    gpos <- GenomicRanges::sort(unique(do.call(c, unname(gposL))))
    if (verbose) {
        message("collapsed ", sum(lengths(gposL)), " positions to ",
                length(gpos), " unique ones")
    }

    # extract read names
    readL <- lapply(dfL, function(df) unique(df$read_id))

    # modified probability
    modmat <- S4Vectors::make_zero_col_DFrame(nrow = length(gpos))
    for (nm in names(fnames)) {
        x <- dfL[[nm]]
        # only record observed values
        idx <- which(x$mod_prob != 0)
        modmat[[nm]] <- SparseArray::SparseArray(Matrix::sparseMatrix(
            i = GenomicRanges::match(gposL[[nm]][idx], gpos),
            j = match(x$read_id[idx], readL[[nm]]),
            x = x$mod_prob[idx],
            dims = c(length(gpos), length(readL[[nm]])),
            dimnames = list(NULL, paste0(nm, "-", readL[[nm]]))
        ))
    }

    # create SummarizedExperiment object
    se <- SummarizedExperiment::SummarizedExperiment(
        assays = list(mod_prob = modmat),
        rowRanges = gpos,
        colData = S4Vectors::DataFrame(
            row.names = names(modmat),
            sample = names(modmat),
            modbase = modbase[names(modmat)]
        ),
        metadata = list(modkit_threshold = modkit_threshold,
                        filter_threshold = filter_threshold)
    )
    rownames(se) <- paste0(
        GenomeInfoDb::seqnames(SummarizedExperiment::rowRanges(se)),
        ":", BiocGenerics::pos(SummarizedExperiment::rowRanges(se)), ":",
        BiocGenerics::strand(SummarizedExperiment::rowRanges(se)))
    colnames(se) <- rownames(SummarizedExperiment::colData(se))

    se
}
